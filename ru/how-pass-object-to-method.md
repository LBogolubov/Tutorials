<?php

use App\HTMLElements;
use App\TutorialModel;
use App\ButtonModel;

/** @var TutorialModel $tutorial */

HTMLElements::tutorialHeader(
    $tutorial,
    [
        new ButtonModel(
            'swift.org',
            'https://docs.swift.org/swift-book/LanguageGuide/Functions.html',
            true
        )
    ]
);

HTMLElements::titleSection(
    'Проблема'
);

HTMLElements::text(
    'У меня небыло проблем с выбором - подсознательно я знал, что здесь нужно передать объект, а здесь только некоторые поля объекта. Это даже не туториал, а цепочка рассуждений для того чтобы объяснить свой выбор.'
);

HTMLElements::text(
    'Представьте метод, вычисляющий возраст у объекта `Car`:'
);

HTMLElements::blockCode('
/*
Обратите внимание, класс `Car` имеет несколько проперти.
*/
class Car {

    var id: String
    var model: String
    var birthday: Date
}

static func age(/* Проблема здесь */) -> Int {
    return Calendar.current.dateComponents([.year], from: self, to: *Объект даты*).year!
}
');

HTMLElements::text(
    'Методу `age` для работы нужна только дата, остальные проперти класса `Car` не важны. Есть два конкурирующих подхода.'
);

HTMLElements::text(
    'Сторонники первого утверждают что в метод нужно передавать только требуемые данные. Это поддерживает сопряжение, облегчает повторное использование (например когда файл кидайте в другие схемы). И конечно инкапсюляция - метод сможет использовать все остальные проперти, а это плохо.'
);

HTMLElements::blockCode('
static func age(from birthday: Date) -> Int { ... }
');

HTMLElements::text(
    'Сторонники второго подхода утверждают что в метод нужно передавать весь объект. Это сохраняет обстракцию и предупреждает будущие изменения. Например, появится дата списания в утиль - считать возраст машины придется не до текущей даты, а до даты списания.'
);

HTMLElements::blockCode('
static func age(for car: Car) -> Int { ... }
');

HTMLElements::text(
    'Если проблема кажется несущественной, значит вы не страдали со схемами и шарингом файлов между ними. Примеры выше отражают крайности, поэтому появляются споры.'
);

HTMLElements::titleSection(
    'Решение'
);
HTMLElements::text(
    'Оба подхода не нарушают код-стайл и делают свою работу. А значит по этим пунктам отбросить неработающий вариант не получится. Считать количество символов - такая же глупость, как спорить про Swift и SwiftUI.'
);

HTMLElements::text(
    'Давайте взглянем на абстрацию. Если метод ожидает конкретные проперти, которые случайно оказались в одном объекте - передавайте их в метод по отдельности. Если же элементы данных принадлежат конкретному объекту и неотделимы, а функция при этом не универсальная - то раскрывая элементы вы нарушаете абстрацию. В этом случае передавайте объект целиком.'
);

HTMLElements::text(
    'Решение для примера выше вариант можете написать в комментариях к посту ' . HTMLElements::embeddedTelegramPostLink("43", 'телеграм канале') . '.'
);

HTMLElements::tutorialFooter($tutorial);
